# Authentication Guide

> Part of [Mattin AI Documentation](../README.md)

## Overview

Mattin AI supports **dual authentication** systems:

- **OIDC Mode** (production): Azure Entra ID / Google OAuth for enterprise authentication
- **FAKE Mode** (development): Email-only login with seeded test users

Authentication is split into:
- **Session-based auth** (internal API): Cookie sessions for frontend
- **API key auth** (public API): Token-based for external access

## Authentication Modes

### OIDC Mode

**OpenID Connect** authentication via enterprise identity providers.

**Supported providers**:
- **Azure Entra ID** (formerly Azure AD) — Microsoft identity platform
- **Google OAuth** — Google Workspace / Gmail accounts

**Configuration** (`.env`):

```bash
# Set authentication mode
AICT_LOGIN=OIDC

# Azure Entra ID (preferred)
OAUTH_PROVIDER=ENTRAID
ENTRA_TENANT_ID=your-tenant-id
ENTRA_CLIENT_ID=your-client-id
ENTRA_CLIENT_SECRET=your-client-secret
ENTRA_REDIRECT_URI=http://localhost:8000/auth/callback

# OR Google OAuth
OAUTH_PROVIDER=GOOGLE
GOOGLE_CLIENT_ID=your-client-id.apps.googleusercontent.com
GOOGLE_CLIENT_SECRET=your-client-secret
GOOGLE_REDIRECT_URI=http://localhost:8000/auth/callback

# Frontend URL (for redirects after login)
FRONTEND_URL=http://localhost:5173
```

**OIDC Flow**:

```
1. User clicks "Login" → Frontend redirects to /internal/auth/login
2. Backend redirects to identity provider (Entra ID / Google)
3. User authenticates with provider
4. Provider redirects to /internal/auth/callback with auth code
5. Backend exchanges code for tokens (access_token, id_token)
6. User info extracted from id_token (email, name, sub)
7. User record created/updated in database
8. Session cookie set → User redirected to frontend
```

**Libraries used**:
- `lks-idprovider-fastapi`: FastAPI OIDC integration
- `lks-idprovider-entraid`: Azure Entra ID provider

**Setup Azure Entra ID**:

1. Register app in Azure Portal: https://portal.azure.com → Azure Active Directory → App registrations
2. Set redirect URI: `http://localhost:8000/auth/callback`
3. Generate client secret
4. Copy tenant ID, client ID, client secret to `.env`

### FAKE Mode

**Development/testing mode** with simplified authentication (no identity provider needed).

**Configuration** (`.env`):

```bash
AICT_LOGIN=FAKE
```

**How it works**:
- Users login with **email only** (no password)
- Email must exist in `seed_dev_users` or database
- Session cookie set immediately (no OAuth flow)

**Seeded development users** (`backend/utils/auth_config.py`):

```python
DEV_USERS = {
    "admin@example.com": {
        "name": "Admin User",
        "role": "omniadmin"
    },
    "user@example.com": {
        "name": "Regular User",
        "role": "user"
    }
}
```

**FAKE Mode endpoints**:

```http
POST /internal/auth/dev-login
Content-Type: application/json

{
  "email": "admin@example.com"
}

Response:
{
  "message": "Login successful",
  "user": {
    "email": "admin@example.com",
    "name": "Admin User",
    "role": "omniadmin"
  }
}
```

**⚠️ Security Warning**: FAKE mode is **insecure** and should **NEVER** be used in production.

### Session-Based Auth

**Cookie-based authentication** for internal API endpoints.

**Session configuration**:

```python
# Backend session settings
SECRET_KEY=your-secret-key-256-bit
SESSION_COOKIE_NAME=mattin_session
SESSION_MAX_AGE=86400  # 24 hours
SESSION_COOKIE_SECURE=True  # HTTPS only (production)
SESSION_COOKIE_HTTPONLY=True
SESSION_COOKIE_SAMESITE=Lax
```

**Session lifecycle**:

1. **Login**: Session created, cookie set with user info
2. **Requests**: Cookie sent automatically by browser
3. **Validation**: `get_current_user_oauth` dependency validates session
4. **Logout**: Session destroyed, cookie cleared

**Frontend usage**:

```typescript
// Login (OIDC mode)
window.location.href = '/internal/auth/login';

// Login (FAKE mode)
await fetch('/internal/auth/dev-login', {
  method: 'POST',
  headers: {'Content-Type': 'application/json'},
  body: JSON.stringify({email: 'user@example.com'}),
  credentials: 'include'  // Important: include cookies
});

// Logout
await fetch('/internal/auth/logout', {
  method: 'POST',
  credentials: 'include'
});
```

## API Key Auth

**Token-based authentication** for public API endpoints.

### Generation

API keys are generated by app owners via internal API:

```http
POST /internal/api_keys?app_id=1
Cookie: session=...
Content-Type: application/json

{
  "name": "Production API Key",
  "rate_limit": 100  // Requests per minute
}

Response:
{
  "key": "mattin_ABC123XYZ...",  // Only shown once!
  "key_id": 5,
  "name": "Production API Key",
  "rate_limit": 100,
  "create_date": "2024-01-15T10:30:00Z"
}
```

**⚠️ Important**: API key is **only displayed once** during creation. Save it immediately.

### Usage

Include API key in `X-API-Key` header:

```http
GET /public/v1/agents?app_id=1
X-API-Key: mattin_ABC123XYZ...
```

### Validation

API keys are validated on each request:

```python
from routers.public.v1.auth import get_api_key_auth

@router.get("/")
async def list_agents(
    api_key: str = Depends(get_api_key_auth),
    db: Session = Depends(get_db)
):
    # api_key validated, rate limit checked
    ...
```

**Validation checks**:
1. Key exists in database
2. Key status is `active` (not revoked)
3. Rate limit not exceeded
4. App ID matches key's app

### Revocation

Revoke compromised keys:

```http
DELETE /internal/api_keys/5?app_id=1
Cookie: session=...

Response:
{
  "message": "API key revoked successfully"
}
```

## Frontend Auth

### AuthContext

React context providing authentication state:

```typescript
import { useAuth } from '@lksnext/ai-core-tools-base';

function MyComponent() {
  const { user, isAuthenticated, login, logout } = useAuth();
  
  if (!isAuthenticated) {
    return <button onClick={login}>Login</button>;
  }
  
  return (
    <div>
      <p>Welcome, {user.name}!</p>
      <button onClick={logout}>Logout</button>
    </div>
  );
}
```

### OIDCProvider

Wraps app with OIDC context (OIDC mode only):

```typescript
import { OIDCProvider } from '@lksnext/ai-core-tools-base';

function App() {
  return (
    <OIDCProvider>
      <YourApp />
    </OIDCProvider>
  );
}
```

### Protected Routes

Require authentication to access:

```typescript
import { ProtectedRoute } from '@lksnext/ai-core-tools-base';

<Routes>
  <Route path="/playground" element={
    <ProtectedRoute>
      <Playground />
    </ProtectedRoute>
  } />
</Routes>
```

### Admin Routes

Require admin/omniadmin role:

```typescript
import { AdminRoute } from '@lksnext/ai-core-tools-base';

<Routes>
  <Route path="/admin/*" element={
    <AdminRoute>
      <AdminDashboard />
    </AdminRoute>
  } />
</Routes>
```

## Configuration

### Backend Environment Variables

```bash
# Authentication mode
AICT_LOGIN=OIDC  # or FAKE

# OAuth Provider (if OIDC mode)
OAUTH_PROVIDER=ENTRAID  # or GOOGLE

# Azure Entra ID (if OAUTH_PROVIDER=ENTRAID)
ENTRA_TENANT_ID=your-tenant-id
ENTRA_CLIENT_ID=your-client-id
ENTRA_CLIENT_SECRET=your-client-secret
ENTRA_REDIRECT_URI=http://localhost:8000/auth/callback

# Google OAuth (if OAUTH_PROVIDER=GOOGLE)
GOOGLE_CLIENT_ID=your-client-id.apps.googleusercontent.com
GOOGLE_CLIENT_SECRET=your-client-secret
GOOGLE_REDIRECT_URI=http://localhost:8000/auth/callback

# Session configuration
SECRET_KEY=your-secret-key-256-bit
SESSION_COOKIE_SECURE=false  # true in production (HTTPS)

# Frontend URL
FRONTEND_URL=http://localhost:5173

# Omniadmins (see below)
AICT_OMNIADMINS=admin@example.com,superuser@example.com
```

### Frontend Environment Variables

```bash
# API URLs
VITE_API_URL=http://localhost:8000
VITE_INTERNAL_API_URL=http://localhost:8000/internal
VITE_PUBLIC_API_URL=http://localhost:8000/public/v1

# OIDC Configuration (if OIDC mode)
VITE_OIDC_AUTHORITY=https://login.microsoftonline.com/{tenant-id}/v2.0
VITE_OIDC_CLIENT_ID=your-client-id
VITE_OIDC_REDIRECT_URI=http://localhost:5173/callback
VITE_OIDC_SCOPE=openid profile email

# Authentication mode
VITE_AUTH_MODE=OIDC  # or FAKE
```

## Omniadmins

**Omniadmins** are superusers with unrestricted access to all apps and operations.

### Configuration

Set in backend `.env`:

```bash
AICT_OMNIADMINS=admin@example.com,superuser@example.com
```

**Comma-separated list** of email addresses.

### Privileges

Omniadmins can:
- Access all apps (bypass ownership/collaboration checks)
- Perform admin operations (`/internal/admin/*` endpoints)
- View and modify all user accounts
- Access system-level settings

### Role Hierarchy

`omniadmin` is the highest role in the hierarchy:

```
omniadmin > owner > administrator > editor > viewer > user > guest
```

### Checking Omniadmin Status

```python
from routers.controls.role_authorization import is_omniadmin

if is_omniadmin(user_email):
    # Grant full access
    ...
```

## Troubleshooting

### OIDC Mode Issues

| Issue | Cause | Solution |
|-------|-------|----------|
| "Redirect URI mismatch" | Callback URL not registered in provider | Add `http://localhost:8000/auth/callback` to provider's allowed redirects |
| "Invalid client" | Wrong client ID/secret | Verify `ENTRA_CLIENT_ID` and `ENTRA_CLIENT_SECRET` |
| "Tenant not found" | Wrong tenant ID | Verify `ENTRA_TENANT_ID` |
| Login redirect loop | Session cookie not set | Check `SECRET_KEY` is set, cookies enabled in browser |

### FAKE Mode Issues

| Issue | Cause | Solution |
|-------|-------|----------|
| "User not found" | Email not in `DEV_USERS` or database | Add email to `DEV_USERS` in `auth_config.py` |
| Endpoint not found | FAKE mode not enabled | Set `AICT_LOGIN=FAKE` in `.env` |

### API Key Issues

| Issue | Cause | Solution |
|-------|-------|----------|
| "Invalid API key" | Wrong key or typo | Verify key is correct, generate new if lost |
| "API key revoked" | Key was revoked | Generate new key |
| 429 Too Many Requests | Rate limit exceeded | Wait 60 seconds or increase rate limit |

## Security Best Practices

1. **Use OIDC in production**: Never use FAKE mode in production environments
2. **HTTPS required**: Always use HTTPS in production for secure cookie transmission
3. **Rotate secrets**: Periodically rotate `SECRET_KEY` and OAuth client secrets
4. **Secure API keys**: Store API keys in environment variables, not code
5. **Revoke compromised keys**: Immediately revoke keys if compromised
6. **Limit omniadmins**: Only assign omniadmin to trusted users
7. **Session timeout**: Configure appropriate `SESSION_MAX_AGE` (default: 24 hours)
8. **Rate limiting**: Set reasonable rate limits on API keys

## See Also

- [Internal API](../api/internal-api.md) — Session-based authentication
- [Public API](../api/public-api.md) — API key authentication
- [Role Authorization](../reference/role-authorization.md) — RBAC system
- [Backend Architecture](../architecture/backend.md) — Auth router implementation
